/*eslint-disable*/

/*
 * image-to-slices 0.1.3
 * Node.js module for converting image into slices with the given reference lines. Backed by Slices and image-clipper.
 * https://github.com/superRaytin/image-to-slices
 *
 * Copyright 2015, Leon Shi
 * Released under the MIT license.
 */

!(function t(e, n, r) {
  function i(a, s) {
    if (!n[a]) {
      if (!e[a]) {
        const u = typeof require === 'function' && require;
        if (!s && u) return u(a, !0);
        if (o) return o(a, !0);
        throw new Error(`Cannot find module '${a}'`);
      }
      const f = (n[a] = { exports: {} });
      e[a][0].call(
        f.exports,
        (t) => {
          const n = e[a][1][t];
          return i(n || t);
        },
        f,
        f.exports,
        t,
        e,
        n,
        r,
      );
    }
    return n[a].exports;
  }
  for (var o = typeof require === 'function' && require, a = 0; a < r.length; a++) i(r[a]);
  return i;
})(
  {
    1: [
      function(t, e, n) {
        function r(t, e, n, r, a) {
          i.apply(null, arguments), typeof r === 'function' && ((a = r), (r = {}));
          let s;
          return (s = r ? new o(e, n, r) : new o(e, n)), s.slice(t, a);
        }
        function i(t, e, n) {
          if (a.type(t) !== 'String' || a.type(e) !== 'Array' || a.type(n) !== 'Array')
            throw new Error('Invalid arguments.');
        }
        var o = t('./image-to-slices');
        var a = t('./utils');
        (r.configure = function(t, e) {
          o.__configure(t, e);
        }),
          (e.exports = r),
          typeof define === 'function' && define.amd
            ? define(() => r)
            : (typeof window !== 'undefined' || typeof navigator !== 'undefined') &&
              (window.imageToSlices = r);
      },
      { './image-to-slices': 2, './utils': 3 },
    ],
    2: [
      function(t, e, n) {
        function r(t, e, n) {
          if (
            ((n = n || {}),
            (this.lineXArray = s.sortAndUnique(t) || []),
            (this.lineYArray = s.sortAndUnique(e) || []),
            (this.options = {}),
            s.extend(this.options, this.defaults, n),
            !this.lineXArray.length && !this.lineYArray.length)
          )
            throw new Error('At least one reference line');
          if (!this.options.saveToDir && !this.options.saveToDataUrl)
            throw new Error('Either saveToDir or saveToDataUrl must be specified');
          if (u && this.options.saveToDir && !this.options.saveToDataUrl) {
            throw new Error(
              'Does not support saving as file in the Browser, use saveToDataUrl instead',
            );
          }
          return this;
        }
        const i = t('path');
        const o = t('image-clipper');
        const a = t('slices');
        var s = t('./utils');
        var u = s.isBrowser();
        (r.prototype.defaults = {
          saveToDir: null,
          saveToDataUrl: !1,
          clipperOptions: null,
          middleBoundaryMode: !1,
        }),
          (r.prototype.clipChild = function(t, e, n) {
            function r() {
              const t = o.shift();
              const h = a;
              const d = `section-${e}-${h}.${s}`;
              const p = i.join(u, d);
              return (
                a++,
                t
                  ? (l.reset().crop(t.x, t.y, t.width, t.height),
                    void (f
                      ? l.toDataURL((t) => {
                          (c[e - 1].children[h - 1].dataURI = t), r();
                        })
                      : l.toFile(p, () => {
                          r();
                        })))
                  : void n()
              );
            }
            var o = t.slice();
            var a = 1;
            var s = this.imageFormat;
            var u = this.options.saveToDir || '';
            var f = this.options.saveToDataUrl;
            var l = this.clipper;
            var c = this.dataUrlList;
            r();
          }),
          (r.prototype.clip = function(t, e) {
            function n() {
              const l = t.shift();
              const h = c;
              const d = `section-${h}.${u}`;
              const p = i.join(a, d);
              if ((c++, !l)) return void (e && (s ? e(r) : e()));
              if (l.children) {
                const g = l.boundary.leftTop.x + 20;
                const { y } = l.boundary.leftTop;
                const v = l.boundary.rightBottom.x - l.boundary.leftTop.x - 40;
                const m = l.boundary.rightBottom.y - l.boundary.leftTop.y;
                f
                  .reset()
                  .clear(g, y, v, m)
                  .crop(l.x, l.y, l.width, l.height),
                  s
                    ? f.toDataURL((t) => {
                        (r[h - 1].dataURI = t), o.clipChild(l.children, h, n);
                      })
                    : f.toFile(p, () => {
                        o.clipChild(l.children, h, n);
                      });
              } else {
                f.reset().crop(l.x, l.y, l.width, l.height),
                  s
                    ? f.toDataURL((t) => {
                        (r[h - 1].dataURI = t), n();
                      })
                    : f.toFile(p, () => {
                        n();
                      });
              }
            }
            let r;
            var o = this;
            var a = this.options.saveToDir || '';
            var s = this.options.saveToDataUrl;
            var u = this.imageFormat;
            var f = this.clipper;
            const l = t.slice();
            if ((s && (r = this.dataUrlList || (this.dataUrlList = l)), t.length)) {
              var c = 1;
              n();
            }
          }),
          (r.prototype.slice = function(t, e) {
            const n = this;
            const r = this.options;
            const i = this.lineXArray;
            const u = this.lineYArray;
            (this.imageFormat = s.getFileFormat(t)),
              r.clipperOptions &&
                r.clipperOptions.canvas &&
                o.configure('canvas', r.clipperOptions.canvas),
              o(t, function() {
                (n.clipper = this), r.clipperOptions && this.configure(r.clipperOptions);
                const t = this.canvas.width;
                const o = this.canvas.height;
                i.push(o),
                  u.push(t),
                  (n.lineXArray = s.sortAndUnique(i)),
                  (n.lineYArray = s.sortAndUnique(u));
                const f = a(t, o, n.lineXArray, n.lineYArray, {
                  middleBoundaryMode: r.middleBoundaryMode,
                });
                n.clip(f, e);
              });
          }),
          (r.__configure = function(t, e) {
            const n = r.prototype.defaults;
            s.setter(n, t, e);
          }),
          (e.exports = r);
      },
      {
        './utils': 3,
        'image-clipper': 11,
        path: 8,
        slices: 14,
      },
    ],
    3: [
      function(t, e, n) {
        (function(t, n) {
          const r = {};
          (r.isBrowser = function() {
            const t = r.isElectron();
            const e = r.isNW();
            return !t && !e && !(typeof window === 'undefined' || typeof navigator === 'undefined');
          }),
            (r.isNode = function() {
              return !(typeof t === 'undefined' || !t.platform || !t.versions);
            }),
            (r.isNW = function() {
              const e = r.isNode();
              return (
                e && !(typeof n === 'undefined' || !t.__node_webkit || !t.versions['node-webkit'])
              );
            }),
            (r.isElectron = function() {
              const e = r.isNode();
              return e && !(typeof n === 'undefined' || !t.versions.electron);
            }),
            (r.type = function(t) {
              return Object.prototype.toString
                .call(t)
                .split(' ')[1]
                .replace(']', '');
            }),
            (r.each = function(t, e) {
              const n = t.length;
              if (n) for (let r = 0; n > r && e.call(t[r], t[r], r) !== !1; r++);
              else if (typeof n === 'undefined')
                for (const i in t) if (e.call(t[i], t[i], i) === !1) break;
            }),
            (r.extend = function(t) {
              r.each(arguments, (e, n) => {
                n > 0 &&
                  r.each(e, (e, n) => {
                    typeof e !== 'undefined' && (t[n] = e);
                  });
              });
            }),
            (r.setter = function(t, e, n) {
              const i = r.type(e);
              if (i === 'String') {
                if (typeof t[e] === 'undefined') throw new Error('Invalid configuration name.');
                if (typeof n === 'undefined')
                  throw new Error('Lack of a value corresponding to the name');
                r.type(n) === 'Object' && r.type(t[e]) === 'Object'
                  ? r.extend(t[e], n)
                  : (t[e] = n);
              } else {
                if (i !== 'Object') throw new Error('Invalid arguments');
                (n = e), r.extend(t, n);
              }
            }),
            (r.getFileFormat = function(t) {
              const e = t.substr(t.lastIndexOf('.') + 1, t.length);
              return e;
            }),
            (r.sortAndUnique = function(t) {
              const e = [];
              const n = {};
              return (
                r.each(t, (t) => {
                  n[t] || (e.push(t), (n[t] = !0));
                }),
                e.sort((t, e) => t - e > 0)
              );
            }),
            (e.exports = r);
        }.call(
          this,
          t('1YiZ5S'),
          typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {},
        ));
      },
      { '1YiZ5S': 9 },
    ],
    4: [function(t, e, n) {}, {}],
    5: [
      function(t, e, n) {
        function r(t, e, n) {
          if (!(this instanceof r)) return new r(t, e, n);
          const i = typeof t;
          if (e === 'base64' && i === 'string') for (t = F(t); t.length % 4 !== 0; ) t += '=';
          let o;
          if (i === 'number') o = T(t);
          else if (i === 'string') o = r.byteLength(t, e);
          else {
            if (i !== 'object')
              throw new Error('First argument needs to be a number, array or string.');
            o = T(t.length);
          }
          let a;
          r._useTypedArrays
            ? (a = r._augment(new Uint8Array(o)))
            : ((a = this), (a.length = o), (a._isBuffer = !0));
          let s;
          if (r._useTypedArrays && typeof t.byteLength === 'number') a._set(t);
          else if (S(t))
            for (s = 0; o > s; s++) r.isBuffer(t) ? (a[s] = t.readUInt8(s)) : (a[s] = t[s]);
          else if (i === 'string') a.write(t, 0, e);
          else if (i === 'number' && !r._useTypedArrays && !n) for (s = 0; o > s; s++) a[s] = 0;
          return a;
        }
        function i(t, e, n, i) {
          n = Number(n) || 0;
          const o = t.length - n;
          i ? ((i = Number(i)), i > o && (i = o)) : (i = o);
          const a = e.length;
          X(a % 2 === 0, 'Invalid hex string'), i > a / 2 && (i = a / 2);
          for (var s = 0; i > s; s++) {
            const u = parseInt(e.substr(2 * s, 2), 16);
            X(!isNaN(u), 'Invalid hex string'), (t[n + s] = u);
          }
          return (r._charsWritten = 2 * s), s;
        }
        function o(t, e, n, i) {
          const o = (r._charsWritten = q(N(e), t, n, i));
          return o;
        }
        function a(t, e, n, i) {
          const o = (r._charsWritten = q(D(e), t, n, i));
          return o;
        }
        function s(t, e, n, r) {
          return a(t, e, n, r);
        }
        function u(t, e, n, i) {
          const o = (r._charsWritten = q(j(e), t, n, i));
          return o;
        }
        function f(t, e, n, i) {
          const o = (r._charsWritten = q(M(e), t, n, i));
          return o;
        }
        function l(t, e, n) {
          return e === 0 && n === t.length ? W.fromByteArray(t) : W.fromByteArray(t.slice(e, n));
        }
        function c(t, e, n) {
          let r = '';
          let i = '';
          n = Math.min(t.length, n);
          for (let o = e; n > o; o++) {
            t[o] <= 127
              ? ((r += O(i) + String.fromCharCode(t[o])), (i = ''))
              : (i += `%${t[o].toString(16)}`);
          }
          return r + O(i);
        }
        function h(t, e, n) {
          let r = '';
          n = Math.min(t.length, n);
          for (let i = e; n > i; i++) r += String.fromCharCode(t[i]);
          return r;
        }
        function d(t, e, n) {
          return h(t, e, n);
        }
        function p(t, e, n) {
          const r = t.length;
          (!e || e < 0) && (e = 0), (!n || n < 0 || n > r) && (n = r);
          for (var i = '', o = e; n > o; o++) i += k(t[o]);
          return i;
        }
        function g(t, e, n) {
          for (var r = t.slice(e, n), i = '', o = 0; o < r.length; o += 2)
            i += String.fromCharCode(r[o] + 256 * r[o + 1]);
          return i;
        }
        function y(t, e, n, r) {
          r ||
            (X(typeof n === 'boolean', 'missing or invalid endian'),
            X(void 0 !== e && e !== null, 'missing offset'),
            X(e + 1 < t.length, 'Trying to read beyond buffer length'));
          const i = t.length;
          if (!(e >= i)) {
            let o;
            return (
              n
                ? ((o = t[e]), i > e + 1 && (o |= t[e + 1] << 8))
                : ((o = t[e] << 8), i > e + 1 && (o |= t[e + 1])),
              o
            );
          }
        }
        function v(t, e, n, r) {
          r ||
            (X(typeof n === 'boolean', 'missing or invalid endian'),
            X(void 0 !== e && e !== null, 'missing offset'),
            X(e + 3 < t.length, 'Trying to read beyond buffer length'));
          const i = t.length;
          if (!(e >= i)) {
            let o;
            return (
              n
                ? (i > e + 2 && (o = t[e + 2] << 16),
                  i > e + 1 && (o |= t[e + 1] << 8),
                  (o |= t[e]),
                  i > e + 3 && (o += (t[e + 3] << 24) >>> 0))
                : (i > e + 1 && (o = t[e + 1] << 16),
                  i > e + 2 && (o |= t[e + 2] << 8),
                  i > e + 3 && (o |= t[e + 3]),
                  (o += (t[e] << 24) >>> 0)),
              o
            );
          }
        }
        function m(t, e, n, r) {
          r ||
            (X(typeof n === 'boolean', 'missing or invalid endian'),
            X(void 0 !== e && e !== null, 'missing offset'),
            X(e + 1 < t.length, 'Trying to read beyond buffer length'));
          const i = t.length;
          if (!(e >= i)) {
            const o = y(t, e, n, !0);
            const a = 32768 & o;
            return a ? -1 * (65535 - o + 1) : o;
          }
        }
        function w(t, e, n, r) {
          r ||
            (X(typeof n === 'boolean', 'missing or invalid endian'),
            X(void 0 !== e && e !== null, 'missing offset'),
            X(e + 3 < t.length, 'Trying to read beyond buffer length'));
          const i = t.length;
          if (!(e >= i)) {
            const o = v(t, e, n, !0);
            const a = 2147483648 & o;
            return a ? -1 * (4294967295 - o + 1) : o;
          }
        }
        function b(t, e, n, r) {
          return (
            r ||
              (X(typeof n === 'boolean', 'missing or invalid endian'),
              X(e + 3 < t.length, 'Trying to read beyond buffer length')),
            Q.read(t, e, n, 23, 4)
          );
        }
        function E(t, e, n, r) {
          return (
            r ||
              (X(typeof n === 'boolean', 'missing or invalid endian'),
              X(e + 7 < t.length, 'Trying to read beyond buffer length')),
            Q.read(t, e, n, 52, 8)
          );
        }
        function I(t, e, n, r, i) {
          i ||
            (X(void 0 !== e && e !== null, 'missing value'),
            X(typeof r === 'boolean', 'missing or invalid endian'),
            X(void 0 !== n && n !== null, 'missing offset'),
            X(n + 1 < t.length, 'trying to write beyond buffer length'),
            R(e, 65535));
          const o = t.length;
          if (!(n >= o))
            for (let a = 0, s = Math.min(o - n, 2); s > a; a++)
              t[n + a] = (e & (255 << (8 * (r ? a : 1 - a)))) >>> (8 * (r ? a : 1 - a));
        }
        function A(t, e, n, r, i) {
          i ||
            (X(void 0 !== e && e !== null, 'missing value'),
            X(typeof r === 'boolean', 'missing or invalid endian'),
            X(void 0 !== n && n !== null, 'missing offset'),
            X(n + 3 < t.length, 'trying to write beyond buffer length'),
            R(e, 4294967295));
          const o = t.length;
          if (!(n >= o))
            for (let a = 0, s = Math.min(o - n, 4); s > a; a++)
              t[n + a] = (e >>> (8 * (r ? a : 3 - a))) & 255;
        }
        function U(t, e, n, r, i) {
          i ||
            (X(void 0 !== e && e !== null, 'missing value'),
            X(typeof r === 'boolean', 'missing or invalid endian'),
            X(void 0 !== n && n !== null, 'missing offset'),
            X(n + 1 < t.length, 'Trying to write beyond buffer length'),
            Y(e, 32767, -32768));
          const o = t.length;
          n >= o || (e >= 0 ? I(t, e, n, r, i) : I(t, 65535 + e + 1, n, r, i));
        }
        function B(t, e, n, r, i) {
          i ||
            (X(void 0 !== e && e !== null, 'missing value'),
            X(typeof r === 'boolean', 'missing or invalid endian'),
            X(void 0 !== n && n !== null, 'missing offset'),
            X(n + 3 < t.length, 'Trying to write beyond buffer length'),
            Y(e, 2147483647, -2147483648));
          const o = t.length;
          n >= o || (e >= 0 ? A(t, e, n, r, i) : A(t, 4294967295 + e + 1, n, r, i));
        }
        function L(t, e, n, r, i) {
          i ||
            (X(void 0 !== e && e !== null, 'missing value'),
            X(typeof r === 'boolean', 'missing or invalid endian'),
            X(void 0 !== n && n !== null, 'missing offset'),
            X(n + 3 < t.length, 'Trying to write beyond buffer length'),
            z(e, 3.4028234663852886e38, -3.4028234663852886e38));
          const o = t.length;
          n >= o || Q.write(t, e, n, r, 23, 4);
        }
        function x(t, e, n, r, i) {
          i ||
            (X(void 0 !== e && e !== null, 'missing value'),
            X(typeof r === 'boolean', 'missing or invalid endian'),
            X(void 0 !== n && n !== null, 'missing offset'),
            X(n + 7 < t.length, 'Trying to write beyond buffer length'),
            z(e, 1.7976931348623157e308, -1.7976931348623157e308));
          const o = t.length;
          n >= o || Q.write(t, e, n, r, 52, 8);
        }
        function F(t) {
          return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, '');
        }
        function _(t, e, n) {
          return typeof t !== 'number'
            ? n
            : ((t = ~~t), t >= e ? e : t >= 0 ? t : ((t += e), t >= 0 ? t : 0));
        }
        function T(t) {
          return (t = ~~Math.ceil(+t)), t < 0 ? 0 : t;
        }
        function C(t) {
          return (
            Array.isArray ||
            function(t) {
              return Object.prototype.toString.call(t) === '[object Array]';
            }
          )(t);
        }
        function S(t) {
          return (
            C(t) || r.isBuffer(t) || (t && typeof t === 'object' && typeof t.length === 'number')
          );
        }
        function k(t) {
          return t < 16 ? `0${t.toString(16)}` : t.toString(16);
        }
        function N(t) {
          for (var e = [], n = 0; n < t.length; n++) {
            const r = t.charCodeAt(n);
            if (r <= 127) e.push(t.charCodeAt(n));
            else {
              const i = n;
              r >= 55296 && r <= 57343 && n++;
              for (
                let o = encodeURIComponent(t.slice(i, n + 1))
                    .substr(1)
                    .split('%'),
                  a = 0;
                a < o.length;
                a++
              )
                e.push(parseInt(o[a], 16));
            }
          }
          return e;
        }
        function D(t) {
          for (var e = [], n = 0; n < t.length; n++) e.push(255 & t.charCodeAt(n));
          return e;
        }
        function M(t) {
          for (var e, n, r, i = [], o = 0; o < t.length; o++)
            (e = t.charCodeAt(o)), (n = e >> 8), (r = e % 256), i.push(r), i.push(n);
          return i;
        }
        function j(t) {
          return W.toByteArray(t);
        }
        function q(t, e, n, r) {
          for (var i = 0; r > i && !(i + n >= e.length || i >= t.length); i++) e[i + n] = t[i];
          return i;
        }
        function O(t) {
          try {
            return decodeURIComponent(t);
          } catch (e) {
            return String.fromCharCode(65533);
          }
        }
        function R(t, e) {
          X(typeof t === 'number', 'cannot write a non-number as a number'),
            X(t >= 0, 'specified a negative value for writing an unsigned value'),
            X(e >= t, 'value is larger than maximum value for type'),
            X(Math.floor(t) === t, 'value has a fractional component');
        }
        function Y(t, e, n) {
          X(typeof t === 'number', 'cannot write a non-number as a number'),
            X(e >= t, 'value larger than maximum allowed value'),
            X(t >= n, 'value smaller than minimum allowed value'),
            X(Math.floor(t) === t, 'value has a fractional component');
        }
        function z(t, e, n) {
          X(typeof t === 'number', 'cannot write a non-number as a number'),
            X(e >= t, 'value larger than maximum allowed value'),
            X(t >= n, 'value smaller than minimum allowed value');
        }
        function X(t, e) {
          if (!t) throw new Error(e || 'Failed assertion');
        }
        var W = t('base64-js');
        var Q = t('ieee754');
        (n.Buffer = r),
          (n.SlowBuffer = r),
          (n.INSPECT_MAX_BYTES = 50),
          (r.poolSize = 8192),
          (r._useTypedArrays = (function() {
            try {
              const t = new ArrayBuffer(0);
              const e = new Uint8Array(t);
              return (
                (e.foo = function() {
                  return 42;
                }),
                e.foo() === 42 && typeof e.subarray === 'function'
              );
            } catch (n) {
              return !1;
            }
          })()),
          (r.isEncoding = function(t) {
            switch (String(t).toLowerCase()) {
              case 'hex':
              case 'utf8':
              case 'utf-8':
              case 'ascii':
              case 'binary':
              case 'base64':
              case 'raw':
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return !0;
              default:
                return !1;
            }
          }),
          (r.isBuffer = function(t) {
            return !(t === null || void 0 === t || !t._isBuffer);
          }),
          (r.byteLength = function(t, e) {
            let n;
            switch (((t += ''), e || 'utf8')) {
              case 'hex':
                n = t.length / 2;
                break;
              case 'utf8':
              case 'utf-8':
                n = N(t).length;
                break;
              case 'ascii':
              case 'binary':
              case 'raw':
                n = t.length;
                break;
              case 'base64':
                n = j(t).length;
                break;
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                n = 2 * t.length;
                break;
              default:
                throw new Error('Unknown encoding');
            }
            return n;
          }),
          (r.concat = function(t, e) {
            if (
              (X(C(t), 'Usage: Buffer.concat(list, [totalLength])\nlist should be an Array.'),
              t.length === 0)
            )
              return new r(0);
            if (t.length === 1) return t[0];
            let n;
            if (typeof e !== 'number') for (e = 0, n = 0; n < t.length; n++) e += t[n].length;
            const i = new r(e);
            let o = 0;
            for (n = 0; n < t.length; n++) {
              const a = t[n];
              a.copy(i, o), (o += a.length);
            }
            return i;
          }),
          (r.prototype.write = function(t, e, n, r) {
            if (isFinite(e)) isFinite(n) || ((r = n), (n = void 0));
            else {
              const l = r;
              (r = e), (e = n), (n = l);
            }
            e = Number(e) || 0;
            const c = this.length - e;
            n ? ((n = Number(n)), n > c && (n = c)) : (n = c),
              (r = String(r || 'utf8').toLowerCase());
            let h;
            switch (r) {
              case 'hex':
                h = i(this, t, e, n);
                break;
              case 'utf8':
              case 'utf-8':
                h = o(this, t, e, n);
                break;
              case 'ascii':
                h = a(this, t, e, n);
                break;
              case 'binary':
                h = s(this, t, e, n);
                break;
              case 'base64':
                h = u(this, t, e, n);
                break;
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                h = f(this, t, e, n);
                break;
              default:
                throw new Error('Unknown encoding');
            }
            return h;
          }),
          (r.prototype.toString = function(t, e, n) {
            const r = this;
            if (
              ((t = String(t || 'utf8').toLowerCase()),
              (e = Number(e) || 0),
              (n = void 0 !== n ? Number(n) : (n = r.length)),
              n === e)
            )
              return '';
            let i;
            switch (t) {
              case 'hex':
                i = p(r, e, n);
                break;
              case 'utf8':
              case 'utf-8':
                i = c(r, e, n);
                break;
              case 'ascii':
                i = h(r, e, n);
                break;
              case 'binary':
                i = d(r, e, n);
                break;
              case 'base64':
                i = l(r, e, n);
                break;
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                i = g(r, e, n);
                break;
              default:
                throw new Error('Unknown encoding');
            }
            return i;
          }),
          (r.prototype.toJSON = function() {
            return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) };
          }),
          (r.prototype.copy = function(t, e, n, i) {
            const o = this;
            if (
              (n || (n = 0),
              i || i === 0 || (i = this.length),
              e || (e = 0),
              i !== n && t.length !== 0 && o.length !== 0)
            ) {
              X(i >= n, 'sourceEnd < sourceStart'),
                X(e >= 0 && e < t.length, 'targetStart out of bounds'),
                X(n >= 0 && n < o.length, 'sourceStart out of bounds'),
                X(i >= 0 && i <= o.length, 'sourceEnd out of bounds'),
                i > this.length && (i = this.length),
                t.length - e < i - n && (i = t.length - e + n);
              const a = i - n;
              if (a < 100 || !r._useTypedArrays) for (let s = 0; a > s; s++) t[s + e] = this[s + n];
              else t._set(this.subarray(n, n + a), e);
            }
          }),
          (r.prototype.slice = function(t, e) {
            const n = this.length;
            if (((t = _(t, n, 0)), (e = _(e, n, n)), r._useTypedArrays))
              return r._augment(this.subarray(t, e));
            for (var i = e - t, o = new r(i, void 0, !0), a = 0; i > a; a++) o[a] = this[a + t];
            return o;
          }),
          (r.prototype.get = function(t) {
            return (
              console.log('.get() is deprecated. Access using array indexes instead.'),
              this.readUInt8(t)
            );
          }),
          (r.prototype.set = function(t, e) {
            return (
              console.log('.set() is deprecated. Access using array indexes instead.'),
              this.writeUInt8(t, e)
            );
          }),
          (r.prototype.readUInt8 = function(t, e) {
            return (
              e ||
                (X(void 0 !== t && t !== null, 'missing offset'),
                X(t < this.length, 'Trying to read beyond buffer length')),
              t >= this.length ? void 0 : this[t]
            );
          }),
          (r.prototype.readUInt16LE = function(t, e) {
            return y(this, t, !0, e);
          }),
          (r.prototype.readUInt16BE = function(t, e) {
            return y(this, t, !1, e);
          }),
          (r.prototype.readUInt32LE = function(t, e) {
            return v(this, t, !0, e);
          }),
          (r.prototype.readUInt32BE = function(t, e) {
            return v(this, t, !1, e);
          }),
          (r.prototype.readInt8 = function(t, e) {
            if (
              (e ||
                (X(void 0 !== t && t !== null, 'missing offset'),
                X(t < this.length, 'Trying to read beyond buffer length')),
              !(t >= this.length))
            ) {
              const n = 128 & this[t];
              return n ? -1 * (255 - this[t] + 1) : this[t];
            }
          }),
          (r.prototype.readInt16LE = function(t, e) {
            return m(this, t, !0, e);
          }),
          (r.prototype.readInt16BE = function(t, e) {
            return m(this, t, !1, e);
          }),
          (r.prototype.readInt32LE = function(t, e) {
            return w(this, t, !0, e);
          }),
          (r.prototype.readInt32BE = function(t, e) {
            return w(this, t, !1, e);
          }),
          (r.prototype.readFloatLE = function(t, e) {
            return b(this, t, !0, e);
          }),
          (r.prototype.readFloatBE = function(t, e) {
            return b(this, t, !1, e);
          }),
          (r.prototype.readDoubleLE = function(t, e) {
            return E(this, t, !0, e);
          }),
          (r.prototype.readDoubleBE = function(t, e) {
            return E(this, t, !1, e);
          }),
          (r.prototype.writeUInt8 = function(t, e, n) {
            n ||
              (X(void 0 !== t && t !== null, 'missing value'),
              X(void 0 !== e && e !== null, 'missing offset'),
              X(e < this.length, 'trying to write beyond buffer length'),
              R(t, 255)),
              e >= this.length || (this[e] = t);
          }),
          (r.prototype.writeUInt16LE = function(t, e, n) {
            I(this, t, e, !0, n);
          }),
          (r.prototype.writeUInt16BE = function(t, e, n) {
            I(this, t, e, !1, n);
          }),
          (r.prototype.writeUInt32LE = function(t, e, n) {
            A(this, t, e, !0, n);
          }),
          (r.prototype.writeUInt32BE = function(t, e, n) {
            A(this, t, e, !1, n);
          }),
          (r.prototype.writeInt8 = function(t, e, n) {
            n ||
              (X(void 0 !== t && t !== null, 'missing value'),
              X(void 0 !== e && e !== null, 'missing offset'),
              X(e < this.length, 'Trying to write beyond buffer length'),
              Y(t, 127, -128)),
              e >= this.length ||
                (t >= 0 ? this.writeUInt8(t, e, n) : this.writeUInt8(255 + t + 1, e, n));
          }),
          (r.prototype.writeInt16LE = function(t, e, n) {
            U(this, t, e, !0, n);
          }),
          (r.prototype.writeInt16BE = function(t, e, n) {
            U(this, t, e, !1, n);
          }),
          (r.prototype.writeInt32LE = function(t, e, n) {
            B(this, t, e, !0, n);
          }),
          (r.prototype.writeInt32BE = function(t, e, n) {
            B(this, t, e, !1, n);
          }),
          (r.prototype.writeFloatLE = function(t, e, n) {
            L(this, t, e, !0, n);
          }),
          (r.prototype.writeFloatBE = function(t, e, n) {
            L(this, t, e, !1, n);
          }),
          (r.prototype.writeDoubleLE = function(t, e, n) {
            x(this, t, e, !0, n);
          }),
          (r.prototype.writeDoubleBE = function(t, e, n) {
            x(this, t, e, !1, n);
          }),
          (r.prototype.fill = function(t, e, n) {
            if (
              (t || (t = 0),
              e || (e = 0),
              n || (n = this.length),
              typeof t === 'string' && (t = t.charCodeAt(0)),
              X(typeof t === 'number' && !isNaN(t), 'value is not a number'),
              X(n >= e, 'end < start'),
              n !== e && this.length !== 0)
            ) {
              X(e >= 0 && e < this.length, 'start out of bounds'),
                X(n >= 0 && n <= this.length, 'end out of bounds');
              for (let r = e; n > r; r++) this[r] = t;
            }
          }),
          (r.prototype.inspect = function() {
            for (var t = [], e = this.length, r = 0; e > r; r++) {
              if (((t[r] = k(this[r])), r === n.INSPECT_MAX_BYTES)) {
                t[r + 1] = '...';
                break;
              }
            }
            return `<Buffer ${t.join(' ')}>`;
          }),
          (r.prototype.toArrayBuffer = function() {
            if (typeof Uint8Array !== 'undefined') {
              if (r._useTypedArrays) return new r(this).buffer;
              for (var t = new Uint8Array(this.length), e = 0, n = t.length; n > e; e += 1)
                t[e] = this[e];
              return t.buffer;
            }
            throw new Error('Buffer.toArrayBuffer not supported in this browser');
          });
        const Z = r.prototype;
        r._augment = function(t) {
          return (
            (t._isBuffer = !0),
            (t._get = t.get),
            (t._set = t.set),
            (t.get = Z.get),
            (t.set = Z.set),
            (t.write = Z.write),
            (t.toString = Z.toString),
            (t.toLocaleString = Z.toString),
            (t.toJSON = Z.toJSON),
            (t.copy = Z.copy),
            (t.slice = Z.slice),
            (t.readUInt8 = Z.readUInt8),
            (t.readUInt16LE = Z.readUInt16LE),
            (t.readUInt16BE = Z.readUInt16BE),
            (t.readUInt32LE = Z.readUInt32LE),
            (t.readUInt32BE = Z.readUInt32BE),
            (t.readInt8 = Z.readInt8),
            (t.readInt16LE = Z.readInt16LE),
            (t.readInt16BE = Z.readInt16BE),
            (t.readInt32LE = Z.readInt32LE),
            (t.readInt32BE = Z.readInt32BE),
            (t.readFloatLE = Z.readFloatLE),
            (t.readFloatBE = Z.readFloatBE),
            (t.readDoubleLE = Z.readDoubleLE),
            (t.readDoubleBE = Z.readDoubleBE),
            (t.writeUInt8 = Z.writeUInt8),
            (t.writeUInt16LE = Z.writeUInt16LE),
            (t.writeUInt16BE = Z.writeUInt16BE),
            (t.writeUInt32LE = Z.writeUInt32LE),
            (t.writeUInt32BE = Z.writeUInt32BE),
            (t.writeInt8 = Z.writeInt8),
            (t.writeInt16LE = Z.writeInt16LE),
            (t.writeInt16BE = Z.writeInt16BE),
            (t.writeInt32LE = Z.writeInt32LE),
            (t.writeInt32BE = Z.writeInt32BE),
            (t.writeFloatLE = Z.writeFloatLE),
            (t.writeFloatBE = Z.writeFloatBE),
            (t.writeDoubleLE = Z.writeDoubleLE),
            (t.writeDoubleBE = Z.writeDoubleBE),
            (t.fill = Z.fill),
            (t.inspect = Z.inspect),
            (t.toArrayBuffer = Z.toArrayBuffer),
            t
          );
        };
      },
      { 'base64-js': 6, ieee754: 7 },
    ],
    6: [
      function(t, e, n) {
        const r = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        !(function(t) {
          function e(t) {
            const e = t.charCodeAt(0);
            return e === a || e === c
              ? 62
              : e === s || e === h
              ? 63
              : u > e
              ? -1
              : u + 10 > e
              ? e - u + 26 + 26
              : l + 26 > e
              ? e - l
              : f + 26 > e
              ? e - f + 26
              : void 0;
          }
          function n(t) {
            function n(t) {
              f[c++] = t;
            }
            let r;
            let i;
            let a;
            let s;
            let u;
            let f;
            if (t.length % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
            const l = t.length;
            (u = t.charAt(l - 2) === '=' ? 2 : t.charAt(l - 1) === '=' ? 1 : 0),
              (f = new o((3 * t.length) / 4 - u)),
              (a = u > 0 ? t.length - 4 : t.length);
            var c = 0;
            for (r = 0, i = 0; a > r; r += 4, i += 3) {
              (s =
                (e(t.charAt(r)) << 18) |
                (e(t.charAt(r + 1)) << 12) |
                (e(t.charAt(r + 2)) << 6) |
                e(t.charAt(r + 3))),
                n((16711680 & s) >> 16),
                n((65280 & s) >> 8),
                n(255 & s);
            }
            return (
              u === 2
                ? ((s = (e(t.charAt(r)) << 2) | (e(t.charAt(r + 1)) >> 4)), n(255 & s))
                : u === 1 &&
                  ((s =
                    (e(t.charAt(r)) << 10) | (e(t.charAt(r + 1)) << 4) | (e(t.charAt(r + 2)) >> 2)),
                  n((s >> 8) & 255),
                  n(255 & s)),
              f
            );
          }
          function i(t) {
            function e(t) {
              return r.charAt(t);
            }
            function n(t) {
              return e((t >> 18) & 63) + e((t >> 12) & 63) + e((t >> 6) & 63) + e(63 & t);
            }
            let i;
            let o;
            let a;
            const s = t.length % 3;
            let u = '';
            for (i = 0, a = t.length - s; a > i; i += 3)
              (o = (t[i] << 16) + (t[i + 1] << 8) + t[i + 2]), (u += n(o));
            switch (s) {
              case 1:
                (o = t[t.length - 1]), (u += e(o >> 2)), (u += e((o << 4) & 63)), (u += '==');
                break;
              case 2:
                (o = (t[t.length - 2] << 8) + t[t.length - 1]),
                  (u += e(o >> 10)),
                  (u += e((o >> 4) & 63)),
                  (u += e((o << 2) & 63)),
                  (u += '=');
            }
            return u;
          }
          var o = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
          var a = '+'.charCodeAt(0);
          var s = '/'.charCodeAt(0);
          var u = '0'.charCodeAt(0);
          var f = 'a'.charCodeAt(0);
          var l = 'A'.charCodeAt(0);
          var c = '-'.charCodeAt(0);
          var h = '_'.charCodeAt(0);
          (t.toByteArray = n), (t.fromByteArray = i);
        })(typeof n === 'undefined' ? (this.base64js = {}) : n);
      },
      {},
    ],
    7: [
      function(t, e, n) {
        (n.read = function(t, e, n, r, i) {
          let o;
          let a;
          const s = 8 * i - r - 1;
          const u = (1 << s) - 1;
          const f = u >> 1;
          let l = -7;
          let c = n ? i - 1 : 0;
          const h = n ? -1 : 1;
          let d = t[e + c];
          for (
            c += h, o = d & ((1 << -l) - 1), d >>= -l, l += s;
            l > 0;
            o = 256 * o + t[e + c], c += h, l -= 8
          );
          for (
            a = o & ((1 << -l) - 1), o >>= -l, l += r;
            l > 0;
            a = 256 * a + t[e + c], c += h, l -= 8
          );
          if (o === 0) o = 1 - f;
          else {
            if (o === u) return a ? NaN : (d ? -1 : 1) * (1 / 0);
            (a += Math.pow(2, r)), (o -= f);
          }
          return (d ? -1 : 1) * a * Math.pow(2, o - r);
        }),
          (n.write = function(t, e, n, r, i, o) {
            let a;
            let s;
            let u;
            let f = 8 * o - i - 1;
            const l = (1 << f) - 1;
            const c = l >> 1;
            const h = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
            let d = r ? 0 : o - 1;
            const p = r ? 1 : -1;
            const g = e < 0 || (e === 0 && 1 / e < 0) ? 1 : 0;
            for (
              e = Math.abs(e),
                isNaN(e) || e === 1 / 0
                  ? ((s = isNaN(e) ? 1 : 0), (a = l))
                  : ((a = Math.floor(Math.log(e) / Math.LN2)),
                    e * (u = Math.pow(2, -a)) < 1 && (a--, (u *= 2)),
                    (e += a + c >= 1 ? h / u : h * Math.pow(2, 1 - c)),
                    e * u >= 2 && (a++, (u /= 2)),
                    a + c >= l
                      ? ((s = 0), (a = l))
                      : a + c >= 1
                      ? ((s = (e * u - 1) * Math.pow(2, i)), (a += c))
                      : ((s = e * Math.pow(2, c - 1) * Math.pow(2, i)), (a = 0)));
              i >= 8;
              t[n + d] = 255 & s, d += p, s /= 256, i -= 8
            );
            for (a = (a << i) | s, f += i; f > 0; t[n + d] = 255 & a, d += p, a /= 256, f -= 8);
            t[n + d - p] |= 128 * g;
          });
      },
      {},
    ],
    8: [
      function(t, e, n) {
        (function(t) {
          function e(t, e) {
            for (var n = 0, r = t.length - 1; r >= 0; r--) {
              const i = t[r];
              i === '.'
                ? t.splice(r, 1)
                : i === '..'
                ? (t.splice(r, 1), n++)
                : n && (t.splice(r, 1), n--);
            }
            if (e) for (; n--; n) t.unshift('..');
            return t;
          }
          function r(t, e) {
            if (t.filter) return t.filter(e);
            for (var n = [], r = 0; r < t.length; r++) e(t[r], r, t) && n.push(t[r]);
            return n;
          }
          const i = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
          const o = function(t) {
            return i.exec(t).slice(1);
          };
          (n.resolve = function() {
            for (var n = '', i = !1, o = arguments.length - 1; o >= -1 && !i; o--) {
              const a = o >= 0 ? arguments[o] : t.cwd();
              if (typeof a !== 'string')
                throw new TypeError('Arguments to path.resolve must be strings');
              a && ((n = `${a}/${n}`), (i = a.charAt(0) === '/'));
            }
            return (
              (n = e(
                r(n.split('/'), (t) => !!t),
                !i,
              ).join('/')),
              (i ? '/' : '') + n || '.'
            );
          }),
            (n.normalize = function(t) {
              const i = n.isAbsolute(t);
              const o = a(t, -1) === '/';
              return (
                (t = e(
                  r(t.split('/'), (t) => !!t),
                  !i,
                ).join('/')),
                t || i || (t = '.'),
                t && o && (t += '/'),
                (i ? '/' : '') + t
              );
            }),
            (n.isAbsolute = function(t) {
              return t.charAt(0) === '/';
            }),
            (n.join = function() {
              const t = Array.prototype.slice.call(arguments, 0);
              return n.normalize(
                r(t, (t, e) => {
                  if (typeof t !== 'string')
                    throw new TypeError('Arguments to path.join must be strings');
                  return t;
                }).join('/'),
              );
            }),
            (n.relative = function(t, e) {
              function r(t) {
                for (var e = 0; e < t.length && t[e] === ''; e++);
                for (var n = t.length - 1; n >= 0 && t[n] === ''; n--);
                return e > n ? [] : t.slice(e, n - e + 1);
              }
              (t = n.resolve(t).substr(1)), (e = n.resolve(e).substr(1));
              for (
                var i = r(t.split('/')),
                  o = r(e.split('/')),
                  a = Math.min(i.length, o.length),
                  s = a,
                  u = 0;
                a > u;
                u++
              ) {
                if (i[u] !== o[u]) {
                  s = u;
                  break;
                }
              }
              for (var f = [], u = s; u < i.length; u++) f.push('..');
              return (f = f.concat(o.slice(s))), f.join('/');
            }),
            (n.sep = '/'),
            (n.delimiter = ':'),
            (n.dirname = function(t) {
              const e = o(t);
              const n = e[0];
              let r = e[1];
              return n || r ? (r && (r = r.substr(0, r.length - 1)), n + r) : '.';
            }),
            (n.basename = function(t, e) {
              let n = o(t)[2];
              return (
                e && n.substr(-1 * e.length) === e && (n = n.substr(0, n.length - e.length)), n
              );
            }),
            (n.extname = function(t) {
              return o(t)[3];
            });
          var a =
            'ab'.substr(-1) === 'b'
              ? function(t, e, n) {
                  return t.substr(e, n);
                }
              : function(t, e, n) {
                  return e < 0 && (e = t.length + e), t.substr(e, n);
                };
        }.call(this, t('1YiZ5S')));
      },
      { '1YiZ5S': 9 },
    ],
    9: [
      function(t, e, n) {
        function r() {}
        const i = (e.exports = {});
        (i.nextTick = (function() {
          const t = typeof window !== 'undefined' && window.setImmediate;
          const e = typeof window !== 'undefined' && window.postMessage && window.addEventListener;
          if (t) {
            return function(t) {
              return window.setImmediate(t);
            };
          }
          if (e) {
            const n = [];
            return (
              window.addEventListener(
                'message',
                (t) => {
                  const e = t.source;
                  if (
                    (e === window || e === null) &&
                    t.data === 'process-tick' &&
                    (t.stopPropagation(), n.length > 0)
                  ) {
                    const r = n.shift();
                    r();
                  }
                },
                !0,
              ),
              function(t) {
                n.push(t), window.postMessage('process-tick', '*');
              }
            );
          }
          return function(t) {
            setTimeout(t, 0);
          };
        })()),
          (i.title = 'browser'),
          (i.browser = !0),
          (i.env = {}),
          (i.argv = []),
          (i.on = r),
          (i.addListener = r),
          (i.once = r),
          (i.off = r),
          (i.removeListener = r),
          (i.removeAllListeners = r),
          (i.emit = r),
          (i.binding = function(t) {
            throw new Error('process.binding is not supported');
          }),
          (i.cwd = function() {
            return '/';
          }),
          (i.chdir = function(t) {
            throw new Error('process.chdir is not supported');
          });
      },
      {},
    ],
    10: [
      function(t, e, n) {
        (function(n) {
          function r(t) {
            return (
              (t = t || {}),
              (this.options = {}),
              i.extend(this.options, this.defaults, t),
              this.quality(this.options.quality),
              this
            );
          }
          var i = t('./utils');
          const o = t('./polyfills');
          const a = i.isElectron();
          const s = i.isNW();
          const u = i.isBrowser();
          const f = u || a || s;
          (r.prototype.defaults = {
            canvas: null,
            quality: 92,
            maxQuality: 100,
            minQuality: 1,
            bufsize: 4096,
          }),
            (r.prototype.loadImageFromMemory = function(t) {
              const e = this.options;
              t = t || this.originalImage;
              const n = t.width;
              const r = t.height;
              const o = this.__createCanvas(n, r);
              const a = o.getContext('2d');
              return (
                a.drawImage(t, 0, 0, n, r),
                (this.canvas = o),
                (e.imageFormat = e.imageFormat || i.getImageFormat(t.src)),
                this.originalImage || (this.originalImage = t),
                this
              );
            }),
            (r.prototype.loadImageFromUrl = function(t, e) {
              const n = this;
              const r = this.options;
              const o = this.__createImage();
              (r.imageFormat = r.imageFormat || i.getImageFormat(t)),
                (o.onload = function() {
                  n.loadImageFromMemory(o), e.call(n);
                }),
                (o.src = t);
            }),
            (r.prototype.image = function(t, e) {
              const n = this.options;
              const r = i.type(t);
              if (r !== 'String' && r !== 'Image' && r !== 'HTMLImageElement')
                throw new Error('invalid arguments');
              if (r === 'String') {
                if (!e) throw new Error('callback must be specified when load from path');
                (n.imageFormat = n.imageFormat || i.getImageFormat(t)),
                  this.loadImageFromUrl(t, function() {
                    e.call(this);
                  });
              } else if (r === 'Image' || r === 'HTMLImageElement') {
                return (
                  (n.imageFormat = n.imageFormat || i.getImageFormat(t.src)),
                  this.loadImageFromMemory(t),
                  e &&
                    i.type(e) === 'Function' &&
                    (e.call(this),
                    console.warn(
                      'No need to specify callback when load from memory, please use chain-capable method directly like this: clipper(Image).crop(...).resize(...)',
                    )),
                  this
                );
              }
            }),
            (r.prototype.crop = function(t, e, n, r) {
              const i = this.canvas;
              const o = i.getContext('2d');
              const a = o.getImageData(t, e, n, r);
              const s = this.__createCanvas(n, r);
              const u = s.getContext('2d');
              return (
                u.rect(0, 0, n, r),
                (u.fillStyle = 'white'),
                u.fill(),
                u.putImageData(a, 0, 0),
                (this.canvas = s),
                this
              );
            }),
            (r.prototype.toFile = function(t, e) {
              const n = this;
              const r = this.options;
              const i = r.imageFormat;
              return (
                this.toDataURL(function(r) {
                  u
                    ? e.call(n, r)
                    : this.dataUrlToFile(t, r, i, () => {
                        e.call(n);
                      });
                }),
                this
              );
            }),
            (r.prototype.dataUrlToFile = function(t, e, r, i) {
              const a = this;
              const s = e.replace(`data:${r};base64,`, '');
              const u = new n(s, 'base64');
              o.writeFile(t, u, () => {
                i.call(a);
              });
            }),
            (r.prototype.resize = function(t, e) {
              let n;
              let r;
              const i = this.canvas;
              if (!arguments.length)
                throw new Error('resize() must be specified at least one parameter');
              if (arguments.length === 1) {
                if (!t) throw new Error('resize() inappropriate parameter');
                (n = t / i.width), (e = i.height * n);
              } else !t && e && ((r = e / i.height), (t = i.width * r));
              const o = this.__createCanvas(t, e);
              const a = o.getContext('2d');
              return a.drawImage(i, 0, 0, t, e), (this.canvas = o), this;
            }),
            (r.prototype.clear = function(t, e, n, r) {
              const i = this.canvas;
              const o = i.getContext('2d');
              return o.clearRect(t, e, n, r), (o.fillStyle = '#fff'), o.fillRect(t, e, n, r), this;
            }),
            (r.prototype.quality = function(t) {
              if (i.type(t) !== 'Number' && i.type(t) !== 'String')
                throw new Error('Invalid arguments');
              if (!t) return this;
              const e = this.options;
              return (
                (t = parseFloat(t)),
                (t = i.rangeNumber(t, e.minQuality, e.maxQuality)),
                (e.quality = t),
                this
              );
            }),
            (r.prototype.toDataURL = function(t, e) {
              const n = this;
              const r = this.options;
              const a = r.quality;
              const s = r.minQuality;
              const u = r.maxQuality;
              const l = r.imageFormat;
              const c = r.bufsize;
              typeof t === 'string' && (t = parseFloat(t)),
                arguments.length === 0
                  ? (t = a)
                  : arguments.length === 1
                  ? typeof t === 'number'
                    ? (t = i.rangeNumber(t, s, u))
                    : typeof t === 'function' && ((e = t), (t = a))
                  : arguments.length === 2 && (t = i.rangeNumber(t, s, u));
              const h = this.canvas;
              if (f) {
                const d = h.toDataURL(l, t / 100);
                return e && e.call(this, d), d;
              }
              if (!e) throw new Error('toDataURL(): callback must be specified');
              return (
                o.toDataURL(
                  {
                    canvas: h,
                    imageFormat: l,
                    quality: t,
                    bufsize: c,
                  },
                  (t) => {
                    e.call(n, t);
                  },
                ),
                this
              );
            }),
            (r.prototype.configure = function(t, e) {
              const n = this.options;
              return i.setter(n, t, e), n.quality && this.quality(n.quality), this;
            }),
            (r.prototype.getCanvas = function() {
              return this.canvas;
            }),
            (r.prototype.destroy = function() {
              return (this.canvas = null), this;
            }),
            (r.prototype.reset = function() {
              return this.destroy().loadImageFromMemory();
            }),
            (r.prototype.injectNodeCanvas = function(t) {
              typeof t !== 'undefined' && (this.options.canvas = t);
            }),
            (r.prototype.__createCanvas = function(t, e) {
              let n;
              let r;
              if (f) {
                const i = window.document;
                (r = i.createElement('canvas')), (r.width = t), (r.height = e);
              } else {
                if (((n = this.options.canvas), !n || !n.Image))
                  throw new Error('Require node-canvas on the server-side Node.js');
                r = new n(t, e);
              }
              return r;
            }),
            (r.prototype.__createImage = function() {
              let t;
              let e;
              let n;
              if (f) t = window.Image;
              else {
                if (((n = this.options.canvas), !n || !n.Image))
                  throw new Error('Require node-canvas on the server-side Node.js');
                t = n.Image;
              }
              return (e = new t());
            }),
            (r.__configure = function(t, e) {
              const n = r.prototype.defaults;
              i.setter(n, t, e),
                n.quality && (n.quality = i.rangeNumber(n.quality, n.minQuality, n.maxQuality));
            }),
            (e.exports = r);
        }.call(this, t('buffer').Buffer));
      },
      { './polyfills': 12, './utils': 13, buffer: 5 },
    ],
    11: [
      function(t, e, n) {
        function r(t, e, n) {
          let r;
          switch (arguments.length) {
            case 0:
              r = new i();
              break;
            case 1:
              o.type(t) === 'Object' ? (r = new i(t)) : ((r = new i()), r.image(t));
              break;
            case 2:
              (n = e),
                (e = null),
                (r = new i()),
                r.image(t, function() {
                  n.call(this);
                });
              break;
            default:
              if (o.type(e) !== 'Object') throw new Error('invalid arguments');
              (r = new i(e)),
                r.image(t, function() {
                  n.call(this);
                });
          }
          return r;
        }
        var i = t('./clipper');
        var o = t('./utils');
        (r.configure = function(t, e) {
          i.__configure(t, e);
        }),
          (n = e.exports = r),
          (n.imageClipper = r),
          typeof define === 'function' && define.amd
            ? define(() => r)
            : (typeof window !== 'undefined' || typeof navigator !== 'undefined') &&
              (window.imageClipper = r);
      },
      { './clipper': 10, './utils': 13 },
    ],
    12: [
      function(t, e, n) {
        const r = t('fs');
        const i = {};
        (i.writeFile = function(t, e, n) {
          r.writeFile(t, e, (t) => {
            if (t) throw t;
            n();
          });
        }),
          (i.toDataURL = function(t, e) {
            const n = t.canvas;
            const r = t.imageFormat;
            const i = t.quality;
            const o = t.bufsize;
            r === 'image/jpeg'
              ? n.toDataURL(r, { quality: i, bufsize: o }, (t, n) => {
                  if (t) throw t;
                  e(n);
                })
              : n.toDataURL(r, (t, n) => {
                  if (t) throw t;
                  e(n);
                });
          }),
          (e.exports = i);
      },
      { fs: 4 },
    ],
    13: [
      function(t, e, n) {
        (function(t, n) {
          const r = {};
          (r.isBrowser = function() {
            const t = r.isElectron();
            const e = r.isNW();
            return !t && !e && !(typeof window === 'undefined' || typeof navigator === 'undefined');
          }),
            (r.isNode = function() {
              return !(typeof t === 'undefined' || !t.platform || !t.versions);
            }),
            (r.isNW = function() {
              const e = r.isNode();
              return (
                e && !(typeof n === 'undefined' || !t.__node_webkit || !t.versions['node-webkit'])
              );
            }),
            (r.isElectron = function() {
              const e = r.isNode();
              return e && !(typeof n === 'undefined' || !t.versions.electron);
            }),
            (r.type = function(t) {
              return Object.prototype.toString
                .call(t)
                .split(' ')[1]
                .replace(']', '');
            }),
            (r.rangeNumber = function(t, e, n) {
              return t > n ? n : e > t ? e : t;
            }),
            (r.each = function(t, e) {
              const n = t.length;
              if (n) for (let r = 0; n > r && e.call(t[r], t[r], r) !== !1; r++);
              else if (typeof n === 'undefined')
                for (const i in t) if (e.call(t[i], t[i], i) === !1) break;
            }),
            (r.extend = function(t) {
              r.each(arguments, (e, n) => {
                n > 0 &&
                  r.each(e, (e, n) => {
                    typeof e !== 'undefined' && (t[n] = e);
                  });
              });
            }),
            (r.setter = function(t, e, n) {
              const i = r.type(e);
              if (i === 'String') {
                if (typeof t[e] === 'undefined') throw new Error('Invalid configuration name.');
                if (typeof n === 'undefined')
                  throw new Error('Lack of a value corresponding to the name');
                r.type(n) === 'Object' && r.type(t[e]) === 'Object'
                  ? r.extend(t[e], n)
                  : (t[e] = n);
              } else {
                if (i !== 'Object') throw new Error('Invalid arguments');
                (n = e), r.extend(t, n);
              }
            }),
            (r.getImageFormat = function(t) {
              let e = t.substr(t.lastIndexOf('.') + 1, t.length);
              return (e = e === 'jpg' ? 'jpeg' : e), `image/${e}`;
            }),
            (r.upperCaseFirstLetter = function(t) {
              return t.replace(t.charAt(0), (t) => t.toUpperCase());
            }),
            (e.exports = r);
        }.call(
          this,
          t('1YiZ5S'),
          typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {},
        ));
      },
      { '1YiZ5S': 9 },
    ],
    14: [
      function(t, e, n) {
        function r(t, e, n, r, a) {
          i.apply(null, arguments);
          let s;
          return (s = a ? new o(t, e, n, r, a) : new o(t, e, n, r)), s.slice();
        }
        function i(t, e, n, r, i) {
          if (
            a.type(t) !== 'Number' ||
            a.type(e) !== 'Number' ||
            a.type(n) !== 'Array' ||
            a.type(r) !== 'Array' ||
            (i && a.type(i) !== 'Object')
          )
            throw new Error('Invalid arguments.');
        }
        var o = t('./slices');
        var a = t('./utils');
        (n = e.exports = r),
          (n.Slices = r),
          typeof define === 'function' && define.amd
            ? define(() => r)
            : (typeof window !== 'undefined' || typeof navigator !== 'undefined') &&
              (window.Slices = r);
      },
      { './slices': 15, './utils': 16 },
    ],
    15: [
      function(t, e, n) {
        function r(t, e, n, r, o) {
          if (
            ((o = o || {}),
            (this.width = t),
            (this.height = e),
            (n = n || []),
            (r = r || []),
            n.push(e),
            r.push(t),
            (this.lineXArray = i.sortAndUnique(n)),
            (this.lineYArray = i.sortAndUnique(r)),
            (this.options = {}),
            i.extend(this.options, this.defaults, o),
            !this.lineXArray.length && !this.lineYArray.length)
          )
            throw new Error('At least one reference line');
          return this;
        }
        var i = t('./utils');
        (r.prototype.defaults = { middleBoundaryMode: !1 }),
          (r.prototype.slice = function() {
            const t = this.options;
            const e = this.lineXArray;
            const n = this.lineYArray;
            const r = this.width;
            let o = t.middleBoundaryMode;
            const a = e.length;
            const s = n.length;
            o && s < 3 && (o = !1);
            let u;
            let f;
            let l;
            let c;
            let h;
            let d;
            let p;
            let g;
            let y = 0;
            let v = 0;
            let m = 0;
            const w = [];
            if (!s || !a) return this.getChildBlocks();
            if (!o) return this.getChildBlocks();
            for (l = 0, h = a; h > l; l++) {
              for (
                u = e[l],
                  v = n[0],
                  p = {
                    width: r,
                    height: u - y,
                    x: 0,
                    y: l === 0 ? 0 : y,
                    children: [],
                    boundary: {
                      leftTop: { x: n[0], y: l === 0 ? 0 : y },
                      rightBottom: { x: n[s - 2], y: u },
                    },
                  },
                  w.push(p),
                  c = 1,
                  d = s - 1;
                d > c;
                c++
              ) {
                (f = n[c]),
                  (g = {
                    width: f - v,
                    height: u - y,
                    x: v,
                    y: l === 0 ? 0 : y,
                  }),
                  i.extend(g, {
                    left: c === 1 ? 0 : v - n[0],
                    top: 0,
                    parentBlockIndex: m,
                    index: c - 1,
                  }),
                  p.children.push(g),
                  (v = f);
              }
              m++, (y = u);
            }
            return w;
          }),
          (r.prototype.getChildBlocks = function() {
            let t;
            let e;
            let n;
            let r;
            let i;
            let o;
            const a = this.lineXArray;
            const s = this.lineYArray;
            const u = this.width;
            const f = this.height;
            const l = a.length;
            const c = s.length;
            let h = 0;
            let d = 0;
            const p = [];
            if (l) {
              for (n = 0, i = l; i > n; n++) {
                if (((t = a[n]), (d = 0), c)) {
                  for (r = 0, o = c; o > r; r++) {
                    (e = s[r]),
                      p.push({
                        width: e - d,
                        height: t - h,
                        x: d,
                        y: n === 0 ? 0 : h,
                      }),
                      (d = e);
                  }
                } else {
                  p.push({
                    width: u,
                    height: t - h,
                    x: 0,
                    y: n === 0 ? 0 : h,
                  });
                }
                h = t;
              }
            } else {
              for (d = 0, r = 0, o = c; o > r; r++) {
                (e = s[r]),
                  p.push({
                    width: e - d,
                    height: f,
                    x: n === 0 ? 0 : d,
                    y: 0,
                  }),
                  (d = e);
              }
            }
            return p;
          }),
          (e.exports = r);
      },
      { './utils': 16 },
    ],
    16: [
      function(t, e, n) {
        const r = {};
        (r.type = function(t) {
          return Object.prototype.toString
            .call(t)
            .split(' ')[1]
            .replace(']', '');
        }),
          (r.each = function(t, e) {
            const n = t.length;
            if (n) for (let r = 0; n > r && e.call(t[r], t[r], r) !== !1; r++);
            else if (typeof n === 'undefined')
              for (const i in t) if (e.call(t[i], t[i], i) === !1) break;
          }),
          (r.extend = function(t) {
            r.each(arguments, (e, n) => {
              n > 0 &&
                r.each(e, (e, n) => {
                  typeof e !== 'undefined' && (t[n] = e);
                });
            });
          }),
          (r.sortAndUnique = function(t) {
            const e = [];
            const n = {};
            return (
              r.each(t, (t) => {
                n[t] || (e.push(t), (n[t] = !0));
              }),
              e.sort((t, e) => t - e > 0)
            );
          }),
          (e.exports = r);
      },
      {},
    ],
  },
  {},
  [1],
);
